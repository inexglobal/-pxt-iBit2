/// <reference path="../typings/globals/bluebird/index.d.ts" />
/// <reference path="../localtypings/pxtpackage.d.ts" />
/// <reference path="../localtypings/pxtparts.d.ts" />
/// <reference path="../localtypings/pxtarget.d.ts" />
/// <reference path="../typings/globals/winrt/index.d.ts" />
/// <reference path="../typings/globals/marked/index.d.ts" />
/// <reference path="../typings/globals/highlightjs/index.d.ts" />
/// <reference path="typescriptServices.d.ts" />
/// <reference path="../typings/globals/fusejs/index.d.ts" />
declare namespace pxt.analytics {
    function enable(): void;
}
declare namespace ts.pxtc {
    var __dummy: number;
}
import pxtc = ts.pxtc;
declare namespace ts.pxtc.Util {
    function assert(cond: boolean, msg?: string): void;
    function repeatMap<T>(n: number, fn: (index: number) => T): T[];
    function listsEqual<T>(a: T[], b: T[]): boolean;
    function oops(msg?: string): Error;
    function reversed<T>(arr: T[]): T[];
    function flatClone<T>(obj: T): T;
    function clone<T>(v: T): T;
    function iterMap<T>(m: pxt.Map<T>, f: (k: string, v: T) => void): void;
    function mapMap<T, S>(m: pxt.Map<T>, f: (k: string, v: T) => S): pxt.Map<S>;
    function mapStringMapAsync<T, S>(m: pxt.Map<T>, f: (k: string, v: T) => Promise<S>): Promise<pxt.Map<S>>;
    function values<T>(m: pxt.Map<T>): T[];
    function lookup<T>(m: pxt.Map<T>, key: string): T;
    function pushRange<T>(trg: T[], src: T[]): void;
    function concat<T>(arrays: T[][]): T[];
    function memcpy(trg: Uint8Array, trgOff: number, src: Uint8Array, srcOff?: number, len?: number): void;
    function jsonMergeFrom(trg: any, src: any): void;
    function jsonCopyFrom<T>(trg: T, src: T): void;
    function jsonFlatten(v: any): pxt.Map<any>;
    function jsonUnFlatten(v: pxt.Map<any>): any;
    function strcmp(a: string, b: string): number;
    function stringMapEq(a: pxt.Map<string>, b: pxt.Map<string>): boolean;
    function endsWith(str: string, suffix: string): boolean;
    function startsWith(str: string, prefix: string): boolean;
    function replaceAll(str: string, old: string, new_: string): string;
    function sortObjectFields<T>(o: T): T;
    function chopArray<T>(arr: T[], chunkSize: number): T[][];
    function unique<T>(arr: T[], f: (t: T) => string): T[];
    function groupBy<T>(arr: T[], f: (t: T) => string): pxt.Map<T[]>;
    function toDictionary<T>(arr: T[], f: (t: T) => string): pxt.Map<T>;
    interface ArrayLike<T> {
        [index: number]: T;
        length: number;
    }
    function toArray<T>(a: ArrayLike<T>): T[];
    function indexOfMatching<T>(arr: T[], f: (t: T) => boolean): number;
    function nextTick(f: () => void): void;
    function memoizeString<T>(createNew: (id: string) => T): (id: string) => T;
    function memoize<S, T>(getId: (v: S) => string, createNew: (v: S) => T): (id: S) => T;
    function debounce(func: () => void, wait: number, immediate: boolean): () => void;
    function randomPermute<T>(arr: T[]): void;
    function randomPick<T>(arr: T[]): T;
    function getAwesomeAdj(): string;
    function isoTime(time: number): string;
    function timeSince(time: number): string;
    function unicodeToChar(text: string): string;
    function escapeForRegex(str: string): string;
    function stripUrlProtocol(str: string): string;
    let isNodeJS: boolean;
    interface HttpRequestOptions {
        url: string;
        method?: string;
        data?: any;
        headers?: pxt.Map<string>;
        allowHttpErrors?: boolean;
        allowGzipPost?: boolean;
    }
    interface HttpResponse {
        statusCode: number;
        headers: pxt.Map<string>;
        buffer?: any;
        text?: string;
        json?: any;
    }
    function requestAsync(options: HttpRequestOptions): Promise<HttpResponse>;
    function httpGetTextAsync(url: string): Promise<string>;
    function httpGetJsonAsync(url: string): Promise<any>;
    function httpPostJsonAsync(url: string, data: any): Promise<any>;
    function userError(msg: string): Error;
    function stringToUint8Array(input: string): Uint8Array;
    function uint8ArrayToString(input: Uint8Array): string;
    function fromUTF8(binstr: string): string;
    function toUTF8(str: string): string;
    function toHex(bytes: Uint8Array): string;
    function fromHex(hex: string): Uint8Array;
    class PromiseQueue {
        promises: pxt.Map<(() => Promise<any>)[]>;
        enqueue<T>(id: string, f: () => Promise<T>): Promise<T>;
    }
    class PromiseBuffer<T> {
        private waiting;
        private available;
        drain(): void;
        pushError(v: Error): void;
        push(v: T): void;
        shiftAsync(timeout?: number): Promise<T>;
    }
    function now(): number;
    function nowSeconds(): number;
    function getMime(filename: string): string;
    function randomUint32(): number;
    function guidGen(): string;
    var localizeLive: boolean;
    /**
     * Returns the current user language, prepended by "live-" if in live mode
     */
    function localeInfo(): string;
    /**
     * Returns current user language iSO-code. Default is `en`.
     */
    function userLanguage(): string;
    function userLanguageRtl(): boolean;
    function _localize(s: string): string;
    function downloadLiveTranslationsAsync(lang: string, filename: string): Promise<any>;
    function updateLocalizationAsync(baseUrl: string, code: string, live?: boolean): Promise<any>;
    function htmlEscape(_input: string): string;
    function jsStringQuote(s: string): string;
    function jsStringLiteral(s: string): string;
    function fmt_va(f: string, args: any[]): string;
    function fmt(f: string, ...args: any[]): string;
    function dumpLocStats(): void;
    function lf_va(format: string, args: any[]): string;
    function lf(format: string, ...args: any[]): string;
    /**
     * Similar to lf but the string do not get extracted into the loc file.
     */
    function rlf(format: string, ...args: any[]): string;
    let httpRequestCoreAsync: (options: HttpRequestOptions) => Promise<HttpResponse>;
    let sha256: (hashData: string) => string;
    let getRandomBuf: (buf: Uint8Array) => void;
    function capitalize(n: string): string;
    function range(len: number): number[];
    function multipartPostAsync(uri: string, data?: any, filename?: string, filecontents?: string): Promise<HttpResponse>;
    function toDataUri(data: string, mimetype?: string): string;
}
declare namespace ts.pxtc.BrowserImpl {
    function sha256buffer(buf: Uint8Array): string;
    function sha256string(s: string): string;
}
declare namespace pxt {
    export import U = pxtc.Util;
    export import Util = pxtc.Util;
    var appTarget: TargetBundle;
    function setAppTarget(trg: TargetBundle): void;
    interface PxtOptions {
        debug?: boolean;
        light?: boolean;
        wsPort?: number;
    }
    var options: PxtOptions;
    var debug: (msg: any) => void;
    var log: (msg: any) => void;
    var reportException: (err: any, data?: Map<string>) => void;
    var reportError: (cat: string, msg: string, data?: Map<string>) => void;
    /**
     * Track an event.
     */
    var tickEvent: (id: string, data?: Map<string | number>) => void;
    /**
     * Ticks activity events. This event gets aggregated and eventually gets sent.
     */
    function tickActivity(...ids: string[]): void;
    interface WebConfig {
        relprefix: string;
        workerjs: string;
        tdworkerjs: string;
        monacoworkerjs: string;
        pxtVersion: string;
        pxtRelId: string;
        pxtCdnUrl: string;
        commitCdnUrl: string;
        blobCdnUrl: string;
        cdnUrl: string;
        targetUrl: string;
        targetVersion: string;
        targetRelId: string;
        targetId: string;
        simUrl: string;
        partsUrl?: string;
        runUrl?: string;
        docsUrl?: string;
        isStatic?: boolean;
    }
    function localWebConfig(): WebConfig;
    var webConfig: WebConfig;
    function getOnlineCdnUrl(): string;
    function setupWebConfig(cfg: WebConfig): void;
    interface CompileTarget extends pxtc.CompileTarget {
        preferredEditor?: string;
    }
    interface Host {
        readFile(pkg: Package, filename: string): string;
        writeFile(pkg: Package, filename: string, contents: string, force?: boolean): void;
        downloadPackageAsync(pkg: Package): Promise<void>;
        getHexInfoAsync(extInfo: pxtc.ExtensionInfo): Promise<pxtc.HexInfo>;
        cacheStoreAsync(id: string, val: string): Promise<void>;
        cacheGetAsync(id: string): Promise<string>;
    }
    interface FsFile {
        name: string;
        mtime: number;
        content?: string;
        prevContent?: string;
    }
    interface FsPkg {
        path: string;
        config: pxt.PackageConfig;
        files: FsFile[];
        icon?: string;
    }
    interface FsPkgs {
        pkgs: FsPkg[];
    }
    interface ICompilationOptions {
    }
    function getEmbeddedScript(id: string): Map<string>;
    class Package {
        id: string;
        _verspec: string;
        parent: MainPackage;
        static getConfigAsync(id: string, fullVers: string): Promise<pxt.PackageConfig>;
        addedBy: Package[];
        config: PackageConfig;
        level: number;
        isLoaded: boolean;
        private resolvedVersion;
        constructor(id: string, _verspec: string, parent: MainPackage, addedBy: Package);
        version(): string;
        verProtocol(): string;
        verArgument(): string;
        commonDownloadAsync(): Promise<Map<string>>;
        host(): Host;
        readFile(fn: string): string;
        resolveDep(id: string): Package;
        saveConfig(): void;
        private resolveVersionAsync();
        private downloadAsync();
        protected validateConfig(): void;
        isPackageInUse(pkgId: string, ts?: string): boolean;
        getMissingPackages(config: pxt.PackageConfig, ts: string): Map<string>;
        /**
         * For the given package config or ID, looks through all the currently installed packages to find conflicts in
         * Yotta settings
         */
        findConflictsAsync(pkgOrId: string | PackageConfig, version: string): Promise<cpp.PkgConflictError[]>;
        upgradePackage(pkg: string, val: string): string;
        upgradeAPI(fileContents: string): string;
        private parseConfig(cfgSrc);
        loadAsync(isInstall?: boolean): Promise<void>;
        getFiles(): string[];
        addSnapshot(files: Map<string>, exts?: string[]): void;
        /**
         * Returns localized strings qName -> translation
         */
        packageLocalizationStringsAsync(lang: string): Promise<Map<string>>;
    }
    class MainPackage extends Package {
        _host: Host;
        deps: Map<Package>;
        constructor(_host: Host);
        installAllAsync(): Promise<void>;
        sortedDeps(): Package[];
        localizationStringsAsync(lang: string): Promise<Map<string>>;
        getTargetOptions(): CompileTarget;
        getCompileOptionsAsync(target?: CompileTarget): Promise<pxtc.CompileOptions>;
        buildAsync(target: pxtc.CompileTarget): Promise<pxtc.CompileResult>;
        serviceAsync(op: string): Promise<any>;
        filesToBePublishedAsync(allowPrivate?: boolean): Promise<Map<string>>;
        compressToFileAsync(editor?: string): Promise<Uint8Array>;
        computePartDefinitions(parts: string[]): pxt.Map<pxsim.PartDefinition>;
    }
    function targetConfigAsync(): Promise<pxt.TargetConfig>;
    function packagesConfigAsync(): Promise<pxt.PackagesConfig>;
    const CONFIG_NAME: string;
    const CLOUD_ID: string;
    const BLOCKS_PROJECT_NAME: string;
    const JAVASCRIPT_PROJECT_NAME: string;
}
declare namespace pxt.blocks {
    interface BlockParameter {
        name: string;
        type?: string;
        shadowType?: string;
        shadowValue?: string;
    }
    function parameterNames(fn: pxtc.SymbolInfo): Map<BlockParameter>;
    interface FieldDescription {
        n: string;
        pre?: string;
        p?: string;
        ni: number;
    }
    function parseFields(b: string): FieldDescription[];
    interface HelpItem {
        name: string;
        category: string;
        url: string;
        tooltip?: string;
        operators?: Map<string[]>;
        block?: string;
    }
    function helpResources(): Map<HelpItem>;
}
declare namespace pxt.BrowserUtils {
    function isWinRT(): boolean;
    function isIFrame(): boolean;
    function hasNavigator(): boolean;
    function isWindows(): boolean;
    function isMobile(): boolean;
    function isMac(): boolean;
    function isLinux(): boolean;
    function isARM(): boolean;
    function isEdge(): boolean;
    function isIE(): boolean;
    function isChrome(): boolean;
    function isSafari(): boolean;
    function isFirefox(): boolean;
    function isOpera(): boolean;
    function isMidori(): boolean;
    function isEpiphany(): boolean;
    function isTouchEnabled(): boolean;
    function hasSaveAs(): boolean;
    function os(): string;
    function browser(): string;
    function browserVersion(): string;
    function isBrowserSupported(): boolean;
    function bestResourceForOsAndBrowser(resources: pxt.SpecializedResource[], name: string): pxt.SpecializedResource;
    function suggestedBrowserPath(): string;
    function devicePixelRatio(): number;
    function browserDownloadBinText(text: string, name: string, contentType?: string, userContextWindow?: Window, onError?: (err: any) => void): string;
    function browserDownloadText(text: string, name: string, contentType?: string, userContextWindow?: Window, onError?: (err: any) => void): string;
    function isBrowserDownloadInSameWindow(): boolean;
    function browserDownloadDataUri(uri: string, name: string, userContextWindow?: Window): void;
    function browserDownloadUInt8Array(buf: Uint8Array, name: string, contentType?: string, userContextWindow?: Window, onError?: (err: any) => void): string;
    function browserDownloadBase64(b64: string, name: string, contentType?: string, userContextWindow?: Window, onError?: (err: any) => void): string;
}
declare namespace pxt.commands {
    let deployCoreAsync: (r: pxtc.CompileResult) => Promise<void>;
    let browserDownloadAsync: (text: string, name: string, contentType: string) => Promise<void>;
}
declare namespace pxt {
    function lzmaDecompressAsync(buf: Uint8Array): Promise<string>;
    function lzmaCompressAsync(text: string): Promise<Uint8Array>;
}
declare namespace pxt.cpp {
    function nsWriter(nskw?: string): {
        setNs: (ns: string, over?: string) => void;
        clear: () => void;
        write: (s: string) => void;
        incrIndent: () => void;
        decrIndent: () => void;
        finish: () => string;
    };
    function parseCppInt(v: string): number;
    class PkgConflictError extends Error {
        pkg0: Package;
        pkg1: Package;
        settingName: string;
        isUserError: boolean;
        constructor(msg: string);
    }
    function getExtensionInfo(mainPkg: MainPackage): pxtc.ExtensionInfo;
    interface HexFile {
        meta?: {
            cloudId: string;
            targetVersions?: pxt.TargetVersions;
            editor: string;
            name: string;
        };
        source: string;
    }
    function unpackSourceFromHexFileAsync(file: File): Promise<HexFile>;
    function unpackSourceFromHexAsync(dat: Uint8Array): Promise<HexFile>;
}
declare namespace pxt.hex {
    function storeWithLimitAsync(host: Host, idxkey: string, newkey: string, newval: string, maxLen?: number): Promise<void>;
    function recordGetAsync(host: Host, idxkey: string, newkey: string): Promise<void>;
    function getHexInfoAsync(host: Host, extInfo: pxtc.ExtensionInfo, cloudModule?: any): Promise<pxtc.HexInfo>;
}
declare namespace pxt.crowdin {
    const KEY_VARIABLE: string;
    interface DownloadOptions {
        translatedOnly?: boolean;
        validatedOnly?: boolean;
    }
    function downloadTranslationsAsync(branch: string, prj: string, key: string, filename: string, options?: DownloadOptions): Promise<Map<Map<string>>>;
    function createDirectoryAsync(branch: string, prj: string, key: string, name: string, incr?: () => void): Promise<void>;
    function uploadTranslationAsync(branch: string, prj: string, key: string, filename: string, data: string): Promise<void>;
}
declare namespace pxt.docs {
    function htmlQuote(s: string): string;
    function html2Quote(s: string): string;
    interface BreadcrumbEntry {
        name: string;
        href: string;
    }
    var requireMarked: () => any;
    var requireHighlightJs: () => any;
    interface RenderData {
        html: string;
        theme: AppTheme;
        params: Map<string>;
        filepath?: string;
        ghEditURLs?: string[];
        finish?: () => string;
        boxes?: Map<string>;
        macros?: Map<string>;
        settings?: Map<string>;
    }
    function prepTemplate(d: RenderData): void;
    interface RenderOptions {
        template: string;
        markdown: string;
        theme?: AppTheme;
        pubinfo?: Map<string>;
        filepath?: string;
        locale?: Map<string>;
        ghEditURLs?: string[];
    }
    function renderMarkdown(opts: RenderOptions): string;
    function embedUrl(rootUrl: string, tag: string, id: string, height?: number): string;
    function runUrl(url: string, padding: string, id: string): string;
    function docsEmbedUrl(rootUrl: string, id: string, height?: number): string;
    function translate(html: string, locale: Map<string>): {
        text: string;
        missing: Map<string>;
    };
    function buildTOC(summaryMD: string): pxt.TOCMenuEntry[];
    function augmentDocs(baseMd: string, childMd: string): string;
}
declare namespace pxt.github {
    function listRefsAsync(repopath: string, namespace?: string): Promise<string[]>;
    function tagToShaAsync(repopath: string, tag: string): Promise<string>;
    interface CachedPackage {
        sha: string;
        files: Map<string>;
    }
    function pkgConfigAsync(repopath: string, tag?: string): Promise<PackageConfig>;
    function downloadPackageAsync(repoWithTag: string, config: pxt.PackagesConfig, current?: CachedPackage): Promise<CachedPackage>;
    interface ParsedRepo {
        owner?: string;
        fullName: string;
        tag?: string;
    }
    enum GitRepoStatus {
        Unknown = 0,
        Approved = 1,
        Banned = 2,
    }
    interface GitRepo extends ParsedRepo {
        name: string;
        description: string;
        defaultBranch: string;
        status?: GitRepoStatus;
    }
    function repoStatus(rr: ParsedRepo, config: pxt.PackagesConfig): GitRepoStatus;
    function repoAsync(id: string, config: pxt.PackagesConfig): Promise<GitRepo>;
    function searchAsync(query: string, config: pxt.PackagesConfig): Promise<GitRepo[]>;
    function parseRepoUrl(url: string): {
        repo: string;
        tag?: string;
        path?: string;
    };
    function parseRepoId(repo: string): ParsedRepo;
    function isGithubId(id: string): boolean;
    function stringifyRepo(p: ParsedRepo): string;
    function noramlizeRepoId(id: string): string;
    function latestVersionAsync(path: string, config: TargetConfig): Promise<string>;
    function publishGistAsync(token: string, forceNew: boolean, files: any, name: string, currentGistId: string): Promise<any>;
}
declare namespace pxt.HF2 {
    const enum VID {
        ATMEL = 1003,
        ARDUINO = 9025,
        ADAFRUIT = 9114,
        NXP = 3368,
    }
    interface TalkArgs {
        cmd: number;
        data?: Uint8Array;
    }
    interface PacketIO {
        sendPacketAsync(pkt: Uint8Array): Promise<void>;
        onData: (v: Uint8Array) => void;
        onError: (e: Error) => void;
        error(msg: string): any;
        reconnectAsync(): Promise<void>;
        talksAsync?(cmds: TalkArgs[]): Promise<Uint8Array[]>;
        sendSerialAsync?(buf: Uint8Array, useStdErr: boolean): Promise<void>;
        onSerial?: (v: Uint8Array, isErr: boolean) => void;
    }
    function write32(buf: ArrayLike<number>, pos: number, v: number): void;
    function write16(buf: ArrayLike<number>, pos: number, v: number): void;
    function read32(buf: ArrayLike<number>, pos: number): number;
    function read16(buf: ArrayLike<number>, pos: number): number;
    interface BootloaderInfo {
        Header: string;
        Parsed: {
            Version: string;
            Features: string;
        };
        Model: string;
        BoardID: string;
    }
    class Wrapper {
        io: PacketIO;
        private cmdSeq;
        constructor(io: PacketIO);
        private lock;
        infoRaw: string;
        info: BootloaderInfo;
        pageSize: number;
        flashSize: number;
        maxMsgSize: number;
        bootloaderMode: boolean;
        reconnectTries: number;
        msgs: U.PromiseBuffer<Uint8Array>;
        onSerial: (buf: Uint8Array, isStderr: boolean) => void;
        private resetState();
        reconnectAsync(first?: boolean): Promise<void>;
        error(m: string): any;
        talkAsync(cmd: number, data?: Uint8Array): Promise<Uint8Array>;
        private sendMsgAsync(buf);
        sendSerialAsync(buf: Uint8Array, useStdErr?: boolean): Promise<void>;
        private sendMsgCoreAsync(buf, serial?);
        switchToBootloaderAsync(): Promise<void>;
        reflashAsync(blocks: pxtc.UF2.Block[]): Promise<void>;
        readWordsAsync(addr: number, numwords: number): Promise<Uint8Array>;
        flashAsync(blocks: pxtc.UF2.Block[]): Promise<void>;
        private initAsync();
    }
    type ReadAsync = (addr: number, len: number) => Promise<ArrayLike<number>>;
    function onlyChangedBlocksAsync(blocks: pxtc.UF2.Block[], readWordsAsync: ReadAsync): Promise<pxtc.UF2.Block[]>;
}
declare namespace pxt.semver {
    interface Version {
        major: number;
        minor: number;
        patch: number;
        pre: string[];
        build: string[];
    }
    function cmp(a: Version, b: Version): number;
    function parse(v: string): Version;
    function tryParse(v: string): Version;
    function stringify(v: Version): string;
    function majorCmp(a: string, b: string): number;
    function strcmp(a: string, b: string): number;
    function test(): void;
}
declare namespace pxt {
    function simshim(prog: ts.Program): Map<string>;
}
declare namespace pxt.streams {
    interface JsonStreamField {
        name: string;
        sum: number;
        min: number;
        max: number;
        count: number;
    }
    interface JsonStreamMeta {
        fields: JsonStreamField[];
        size: number;
        rows: number;
        batches: number;
    }
    interface JsonStream {
        kind: string;
        id: string;
        time: number;
        name?: string;
        meta: JsonStreamMeta;
        privatekey?: string;
    }
    interface JsonStreamPayload {
        fields: string[];
        values: number[][];
    }
    interface JsonStreamPayloadResponse {
        meta: JsonStreamMeta;
        quotaUsedHere: number;
        quotaLeft: number;
    }
    interface JsonStreamData {
        fields: JsonStreamField[];
        values: number[][];
        continuation?: string;
        continuationUrl?: string;
    }
    function createStreamAsync(target: string, name?: string): Promise<JsonStream>;
    function postPayloadAsync(stream: JsonStream, data: JsonStreamPayload): Promise<void>;
}
declare namespace pxt.usb {
    class USBError extends Error {
        constructor(msg: string);
    }
    const enum VID {
        ATMEL = 1003,
        ARDUINO = 9025,
        ADAFRUIT = 9114,
        NXP = 3368,
    }
    type USBEndpointType = "bulk" | "interrupt" | "isochronous";
    type USBRequestType = "standard" | "class" | "vendor";
    type USBRecipient = "device" | "interface" | "endpoint" | "other";
    type USBTransferStatus = "ok" | "stall" | "babble";
    type USBDirection = "in" | "out";
    type BufferSource = Uint8Array;
    interface USBConfiguration {
        configurationValue: number;
        configurationName: string;
        interfaces: USBInterface[];
    }
    interface USBInterface {
        interfaceNumber: number;
        alternate: USBAlternateInterface;
        alternates: USBAlternateInterface[];
        claimed: boolean;
    }
    interface USBAlternateInterface {
        alternateSetting: number;
        interfaceClass: number;
        interfaceSubclass: number;
        interfaceProtocol: number;
        interfaceName: string;
        endpoints: USBEndpoint[];
    }
    interface USBEndpoint {
        endpointNumber: number;
        direction: USBDirection;
        type: USBEndpointType;
        packetSize: number;
    }
    interface USBDevice {
        vendorId: number;
        productId: number;
        manufacturerName: string;
        productName: string;
        serialNumber: string;
        deviceClass: number;
        deviceSubclass: number;
        deviceProtocol: number;
        deviceVersionMajor: number;
        deviceVersionMinor: number;
        deviceVersionSubminor: number;
        usbVersionMajor: number;
        usbVersionMinor: number;
        usbVersionSubminor: number;
        configurations: USBConfiguration[];
        opened: boolean;
        open(): Promise<void>;
        close(): Promise<void>;
        selectConfiguration(configurationValue: number): Promise<void>;
        claimInterface(interfaceNumber: number): Promise<void>;
        releaseInterface(interfaceNumber: number): Promise<void>;
        selectAlternateInterface(interfaceNumber: number, alternateSetting: number): Promise<void>;
        controlTransferIn(setup: USBControlTransferParameters, length: number): Promise<USBInTransferResult>;
        controlTransferOut(setup: USBControlTransferParameters, data?: BufferSource): Promise<USBOutTransferResult>;
        clearHalt(direction: USBDirection, endpointNumber: number): Promise<void>;
        transferIn(endpointNumber: number, length: number): Promise<USBInTransferResult>;
        transferOut(endpointNumber: number, data: BufferSource): Promise<USBOutTransferResult>;
        isochronousTransferIn(endpointNumber: number, packetLengths: number[]): Promise<USBIsochronousInTransferResult>;
        isochronousTransferOut(endpointNumber: number, data: BufferSource, packetLengths: number[]): Promise<USBIsochronousOutTransferResult>;
        reset(): Promise<void>;
    }
    interface USBControlTransferParameters {
        requestType: USBRequestType;
        recipient: USBRecipient;
        request: number;
        value: number;
        index: number;
    }
    interface USBInTransferResult {
        data: {
            buffer: ArrayBuffer;
        };
        status: USBTransferStatus;
    }
    interface USBOutTransferResult {
        bytesWritten: number;
        status: USBTransferStatus;
    }
    interface USBIsochronousInTransferPacket {
        data: DataView;
        status: USBTransferStatus;
    }
    interface USBIsochronousInTransferResult {
        data: DataView;
        packets: USBIsochronousInTransferPacket[];
    }
    interface USBIsochronousOutTransferPacket {
        bytesWritten: number;
        status: USBTransferStatus;
    }
    interface USBIsochronousOutTransferResult {
        packets: USBIsochronousOutTransferPacket[];
    }
    function initAsync(): Promise<HF2.Wrapper>;
}
declare namespace ts.pxtc.assembler {
    interface InlineError {
        scope: string;
        message: string;
        line: string;
        lineNo: number;
        coremsg: string;
        hints: string;
    }
    interface EmitResult {
        stack: number;
        opcode: number;
        opcode2?: number;
        numArgs?: number[];
        error?: string;
        errorAt?: string;
        labelName?: string;
    }
    function lf(fmt: string, ...args: any[]): string;
    class Instruction {
        opcode: number;
        mask: number;
        jsFormat: string;
        name: string;
        args: string[];
        friendlyFmt: string;
        code: string;
        private ei;
        is32bit: boolean;
        constructor(ei: AbstractProcessor, format: string, opcode: number, mask: number, jsFormat: string);
        emit(ln: Line): EmitResult;
        toString(): string;
    }
    class Line {
        bin: File;
        text: string;
        type: string;
        lineNo: number;
        words: string[];
        scope: string;
        location: number;
        instruction: Instruction;
        numArgs: number[];
        constructor(bin: File, text: string);
        getOpExt(): string;
        getOp(): string;
        update(s: string): void;
    }
    class File {
        constructor(ei: AbstractProcessor);
        baseOffset: number;
        finalEmit: boolean;
        reallyFinalEmit: boolean;
        checkStack: boolean;
        inlineMode: boolean;
        lookupExternalLabel: (name: string) => number;
        normalizeExternalLabel: (n: string) => string;
        private ei;
        private lines;
        private currLineNo;
        private realCurrLineNo;
        private currLine;
        private scope;
        private scopeId;
        errors: InlineError[];
        buf: number[];
        private labels;
        private userLabelsCache;
        private stackpointers;
        private stack;
        peepOps: number;
        peepDel: number;
        private stats;
        throwOnError: boolean;
        disablePeepHole: boolean;
        stackAtLabel: pxt.Map<number>;
        private prevLabel;
        private emitShort(op);
        location(): number;
        pc(): number;
        parseOneInt(s: string): number;
        private looksLikeLabel(name);
        private scopedName(name);
        lookupLabel(name: string, direct?: boolean): number;
        private align(n);
        pushError(msg: string, hints?: string): void;
        private directiveError(msg);
        private emitString(l);
        private parseNumber(words);
        private parseNumbers(words);
        private emitSpace(words);
        private emitBytes(words);
        private emitHex(words);
        private handleDirective(l);
        private handleOneInstruction(ln, instr);
        private handleInstruction(ln);
        private mkLine(tx);
        private prepLines(text);
        private iterLines();
        getSource(clean: boolean): string;
        private peepHole();
        private peepPass(reallyFinal);
        getLabels(): pxt.Map<number>;
        emit(text: string): void;
    }
    interface Encoder {
        name: string;
        pretty: string;
        encode: (v: number) => number;
        isRegister: boolean;
        isImmediate: boolean;
        isRegList: boolean;
        isLabel: boolean;
        isWordAligned?: boolean;
    }
    abstract class AbstractProcessor {
        encoders: pxt.Map<Encoder>;
        instructions: pxt.Map<Instruction[]>;
        file: File;
        constructor();
        wordSize(): number;
        computeStackOffset(kind: string, offset: number): number;
        is32bit(i: Instruction): boolean;
        emit32(v1: number, v2: number, actual: string): EmitResult;
        postProcessRelAddress(f: File, v: number): number;
        postProcessAbsAddress(f: File, v: number): number;
        peephole(ln: Line, lnNext: Line, lnNext2: Line): void;
        registerNo(actual: string): number;
        getAddressFromLabel(f: File, i: Instruction, s: string, wordAligned?: boolean): number;
        isPop(opcode: number): boolean;
        isPush(opcode: number): boolean;
        isAddSP(opcode: number): boolean;
        isSubSP(opcode: number): boolean;
        testAssembler(): void;
        protected addEnc: (n: string, p: string, e: (v: number) => number) => Encoder;
        protected inrange: (max: number, v: number, e: number) => number;
        protected inminmax: (min: number, max: number, v: number, e: number) => number;
        protected inseq: (seq: number[], v: number) => number;
        protected inrangeSigned: (max: number, v: number, e: number) => number;
        protected addInst: (name: string, code: number, mask: number, jsFormat?: string) => void;
    }
    function emitErr(msg: string, tok: string): {
        stack: number;
        opcode: number;
        error: string;
        errorAt: string;
    };
    function expectError(ei: AbstractProcessor, asm: string): void;
    function tohex(n: number): string;
    function expect(ei: AbstractProcessor, disasm: string): void;
}
declare namespace ts.pxtc.avr {
    class AVRProcessor extends assembler.AbstractProcessor {
        wordSize(): number;
        computeStackOffset(kind: string, offset: number): number;
        is32bit(i: assembler.Instruction): boolean;
        emit32(op: number, v: number, actual: string): pxtc.assembler.EmitResult;
        registerNo(actual: string): number;
        postProcessRelAddress(f: assembler.File, v: number): number;
        postProcessAbsAddress(f: assembler.File, v: number): number;
        getAddressFromLabel(f: assembler.File, i: assembler.Instruction, s: string, wordAligned?: boolean): number;
        peephole(ln: pxtc.assembler.Line, lnNext: pxtc.assembler.Line, lnNext2: pxtc.assembler.Line): void;
        constructor();
        testAssembler(): void;
    }
}
declare namespace ts.pxtc {
    var decodeBase64: (s: string) => string;
    interface BitSizeInfo {
        size: number;
        needsSignExt?: boolean;
        immLimit: number;
    }
    abstract class AssemblerSnippets {
        nop(): string;
        reg_gets_imm(reg: string, imm: number): string;
        proc_setup(main?: boolean): string;
        push_fixed(reg: string[]): string;
        push_local(reg: string): string;
        proc_setup_end(): string;
        pop_fixed(reg: string[]): string;
        pop_locals(n: number): string;
        proc_return(): string;
        debugger_hook(lbl: string): string;
        debugger_bkpt(lbl: string): string;
        breakpoint(): string;
        unconditional_branch(lbl: string): string;
        beq(lbl: string): string;
        bne(lbl: string): string;
        cmp(reg1: string, reg: string): string;
        cmp_zero(reg1: string): string;
        load_reg_src_off(reg: string, src: string, off: string, word?: boolean, store?: boolean, inf?: BitSizeInfo): string;
        rt_call(name: string, r0: string, r1: string): string;
        call_lbl(lbl: string): string;
        call_reg(reg: string): string;
        vcall(mapMethod: string, isSet: boolean, vtableShift: number): string;
        prologue_vtable(arg_index: number, vtableShift: number): string;
        lambda_prologue(): string;
        lambda_epilogue(): string;
        load_ptr(lbl: string, reg: string): string;
        emit_int(v: number, reg: string): string;
    }
    function numBytes(n: number): number;
    class ProctoAssembler {
        private t;
        private bin;
        private resText;
        private exprStack;
        private calls;
        private proc;
        constructor(t: AssemblerSnippets, bin: Binary, proc: ir.Procedure);
        private write;
        getAssembly(): string;
        private work();
        private mkLbl(root);
        private terminate(expr);
        private emitJmp(jmp);
        private clearStack();
        private withRef(name, isRef);
        private emitExprInto(e, reg);
        private bitSizeInfo(b);
        private emitExpr(e);
        private emitSharedDef(e);
        private emitSharedTerminate(e);
        private emitRtCall(topExpr);
        private emitHelper(asm);
        private emitProcCall(topExpr);
        private emitStore(trg, src);
        private cellref(cell);
        private emitLambdaWrapper(isMain);
        private emitCallRaw(name);
    }
}
declare namespace ts.pxtc {
    class AVRSnippets extends AssemblerSnippets {
        nop(): string;
        reg_gets_imm(reg: string, imm: number): string;
        push_fixed(regs: string[]): string;
        pop_fixed(regs: string[]): string;
        proc_setup(main?: boolean): string;
        proc_return(): string;
        debugger_hook(lbl: string): string;
        debugger_bkpt(lbl: string): string;
        breakpoint(): string;
        push_local(reg: string): string;
        pop_locals(n: number): string;
        unconditional_branch(lbl: string): string;
        beq(lbl: string): string;
        bne(lbl: string): string;
        cmp(reg1: string, reg2: string): string;
        cmp_zero(reg: string): string;
        load_reg_src_off(reg: string, src: string, off: string, word?: boolean, store?: boolean, inf?: BitSizeInfo): string;
        rt_call(name: string, r0: string, r1: string): string;
        call_lbl(lbl: string): string;
        call_reg(reg: string): string;
        vcall(mapMethod: string, isSet: boolean, vtableShift: number): string;
        prologue_vtable(arg_index: number, vtableShift: number): string;
        lambda_prologue(): string;
        lambda_epilogue(): string;
        load_ptr(lbl: string, reg: string): string;
        emit_int(v: number, reg: string): string;
        rmap_lo: pxt.Map<string>;
        rmap_hi: pxt.Map<string>;
        inst_lo: pxt.Map<string>;
        inst_hi: pxt.Map<string>;
    }
}
declare namespace ts.pxtc {
    function shimToJs(shimName: string): string;
    function jsEmit(bin: Binary): void;
}
declare namespace ts.pxtc {
    class ThumbSnippets extends AssemblerSnippets {
        nop(): string;
        reg_gets_imm(reg: string, imm: number): string;
        push_fixed(regs: string[]): string;
        pop_fixed(regs: string[]): string;
        proc_setup(main?: boolean): string;
        proc_return(): string;
        debugger_hook(lbl: string): string;
        debugger_bkpt(lbl: string): string;
        breakpoint(): string;
        push_local(reg: string): string;
        pop_locals(n: number): string;
        unconditional_branch(lbl: string): string;
        beq(lbl: string): string;
        bne(lbl: string): string;
        cmp(reg1: string, reg2: string): string;
        cmp_zero(reg1: string): string;
        load_reg_src_off(reg: string, src: string, off: string, word: boolean, store: boolean, inf: BitSizeInfo): string;
        rt_call(name: string, r0: string, r1: string): string;
        call_lbl(lbl: string): string;
        call_reg(reg: string): string;
        vcall(mapMethod: string, isSet: boolean, vtableShift: number): string;
        prologue_vtable(arg_top_index: number, vtableShift: number): string;
        lambda_prologue(): string;
        lambda_epilogue(): string;
        load_ptr(lbl: string, reg: string): string;
        emit_int(v: number, reg: string): string;
    }
}
declare namespace pxt.Cloud {
    import Util = pxtc.Util;
    var apiRoot: string;
    var accessToken: string;
    var localToken: string;
    var onOffline: () => void;
    function hasAccessToken(): boolean;
    function isLocalHost(): boolean;
    function privateRequestAsync(options: Util.HttpRequestOptions): Promise<any>;
    function privateGetTextAsync(path: string): Promise<string>;
    function privateGetAsync(path: string): Promise<any>;
    function downloadScriptFilesAsync(id: string): Promise<any>;
    function downloadMarkdownAsync(docid: string, locale?: string, live?: boolean): Promise<string>;
    function privateDeleteAsync(path: string): Promise<any>;
    function privatePostAsync(path: string, data: any): Promise<any>;
    function isLoggedIn(): boolean;
    function isOnline(): boolean;
    function getServiceUrl(): string;
    function getUserId(): string;
    function parseScriptId(uri: string): string;
    interface JsonProgress {
        kind: string;
        userid: string;
        progressid: string;
        index: number;
        completed?: number;
    }
    interface JsonProgressStep {
        index: number;
        text: string;
        count: number;
        minDuration?: number;
        medDuration?: number;
        medModalDuration?: number;
        medPlayDuration?: number;
    }
    interface JsonProgressStats {
        kind: string;
        publicationId: string;
        count: number;
        steps: JsonProgressStep[];
    }
    interface JsonCapability {
        name: string;
        iconurl: string;
    }
    interface JsonIdObject {
        kind: string;
        id: string;
        url: string;
    }
    interface JsonPublication extends JsonIdObject {
        time: number;
        userid: string;
        userscore: number;
        username: string;
        userhaspicture: boolean;
    }
    interface JsonNotification extends JsonPubOnPub {
        notificationkind: string;
        supplementalid: string;
        supplementalkind: string;
        supplementalname: string;
    }
    interface JsonDocument {
        url: string;
        kind: string;
        name: string;
        abstract: string;
        mimetype: string;
        views: number;
        thumburl: string;
    }
    interface JsonArt extends JsonPublication {
        name: string;
        description: string;
        pictureurl: string;
        mediumthumburl: string;
        thumburl: string;
        flags: string[];
        wavurl: string;
        aacurl: string;
        bloburl?: string;
        arttype?: string;
    }
    interface JsonUser extends JsonIdObject {
        name: string;
        about: string;
        features: number;
        receivedpositivereviews: number;
        activedays: number;
        subscribers: number;
        score: number;
        haspicture: boolean;
        isadult?: boolean;
    }
    interface JsonScore {
        points: number;
    }
    interface JsonReceivedPositiveReviewsScore extends JsonScore {
        scripts: JsonScript[];
    }
    interface JsonFeature {
        name: string;
        title: string;
        text: string;
        count: number;
    }
    interface JsonLanguageFeaturesScore extends JsonScore {
        features: JsonFeature[];
    }
    interface JsonUserScore {
        receivedPositiveReviews: JsonReceivedPositiveReviewsScore;
        receivedSubscriptions: JsonScore;
        languageFeatures: JsonLanguageFeaturesScore;
        activeDays: JsonScore;
    }
    interface JsonGroup extends JsonPublication {
        name: string;
        description: string;
        isrestricted: boolean;
        isclass: boolean;
        pictureid: string;
        comments: number;
        positivereviews: number;
        subscribers: number;
    }
    interface JsonCode {
        kind: string;
        time: number;
        expiration: number;
        userid: string;
        username: string;
        userscore: number;
        userhaspicture: boolean;
        verb: string;
        data: string;
        credit?: number;
    }
    interface JsonScriptMeta {
        youtube?: string;
        instagram?: string;
        blocksWidth?: number;
        blocksHeight?: number;
    }
    interface JsonScript extends JsonPublication {
        name: string;
        description: string;
        icon: string;
        iconbackground: string;
        iconurl: string;
        iconArtId?: string;
        splashArtId?: string;
        positivereviews: number;
        cumulativepositivereviews: number;
        comments: number;
        subscribers: number;
        capabilities: JsonCapability[];
        flows: any[];
        haserrors: boolean;
        rootid: string;
        baseid?: string;
        updateid: string;
        updatetime: number;
        ishidden: boolean;
        islibrary: boolean;
        useCppCompiler: boolean;
        installations: number;
        runs: number;
        platforms: string[];
        userplatform?: string[];
        screenshotthumburl: string;
        screenshoturl: string;
        mergeids: string[];
        editor?: string;
        target?: string;
        meta?: JsonScriptMeta;
        updateroot: string;
        unmoderated?: boolean;
        noexternallinks?: boolean;
        promo?: any;
        lastpointer?: string;
    }
    interface JsonHistoryItem {
        kind: string;
        time: number;
        historyid: string;
        scriptstatus: string;
        scriptname: string;
        scriptdescription: string;
        scriptid: string;
        scriptsize?: number;
        isactive: boolean;
        meta: any;
        entryNo?: number;
    }
    interface JsonPubOnPub extends JsonPublication {
        publicationid: string;
        publicationname: string;
        publicationkind: string;
    }
    interface JsonPointer extends JsonPublication {
        path: string;
        scriptid: string;
        artid: string;
        releaseid: string;
        redirect: string;
        description: string;
        htmlartid: string;
        scriptname: string;
        scriptdescription: string;
        breadcrumbtitle: string;
        parentpath: string;
        oldscriptid?: string;
    }
    interface JsonComment extends JsonPubOnPub {
        text: string;
        nestinglevel: number;
        positivereviews: number;
        comments: number;
        assignedtoid?: string;
        resolved?: string;
    }
    interface JsonAbuseReport extends JsonPubOnPub {
        text: string;
        resolution: string;
        publicationuserid: string;
        usernumreports?: number;
        publicationnumabuses?: number;
        publicationusernumabuses?: number;
    }
    interface JsonChannel extends JsonPublication {
        name: string;
        description: string;
        pictureid: string;
        comments: number;
        positivereviews: number;
    }
    interface JsonReview extends JsonPubOnPub {
        ispositive: boolean;
    }
    interface JsonRelease extends JsonPublication {
        name: string;
        releaseid: string;
        labels: JsonReleaseLabel[];
        buildnumber: number;
        version: string;
        commit: string;
        branch: string;
        cdnUrl: string;
    }
    interface JsonReleaseLabel {
        name: string;
        userid: string;
        time: number;
        releaseid: string;
    }
    interface JsonEtag {
        id: string;
        kind: string;
        ETag: string;
    }
    interface JsonList {
        items: JsonIdObject[];
        etags: JsonEtag[];
        continuation: string;
    }
    interface JsonTag extends JsonIdObject {
        time: number;
        name: string;
        category: string;
        description: string;
        instances: number;
        topscreenshotids: string[];
    }
    interface JsonScreenShot extends JsonPubOnPub {
        pictureurl: string;
        thumburl: string;
    }
    interface JsonVideoSource {
        poster?: string;
        srclang: string;
        src: string;
        type: string;
    }
    interface JsonVideoTrack {
        srclang: string;
        src: string;
        kind?: string;
        label?: string;
    }
    interface JsonVideo {
        poster: string;
        tracks?: JsonVideoTrack[];
        sources: JsonVideoSource[];
    }
    interface CanDeleteResponse {
        publicationkind: string;
        publicationname: string;
        publicationuserid: string;
        candelete: boolean;
        candeletekind: boolean;
        canmanage: boolean;
        hasabusereports: boolean;
    }
    interface UserSettings {
        nickname?: string;
        aboutme?: string;
        website?: string;
        notifications?: boolean;
        notifications2?: string;
        picturelinkedtofacebook?: boolean;
        realname?: string;
        gender?: string;
        howfound?: string;
        culture?: string;
        yearofbirth?: number;
        programmingknowledge?: string;
        occupation?: string;
        emailnewsletter2?: string;
        emailfrequency?: string;
        email?: string;
        emailverified?: boolean;
        previousemail?: string;
        location?: string;
        twitterhandle?: string;
        githubuser?: string;
        minecraftuser?: string;
        editorMode?: string;
        school?: string;
        wallpaper?: string;
        permissions?: string;
        credit?: number;
    }
}
declare namespace ts.pxtc.decompiler {
    interface RenameLocation {
        name: string;
        diff: number;
        span: ts.TextSpan;
    }
    class RenameMap {
        private renames;
        constructor(renames: RenameLocation[]);
        getRenamesInSpan(start: number, end: number): RenameLocation[];
        getRenameForPosition(position: number): RenameLocation;
    }
    /**
     * Uses the language service to ensure that there are no duplicate variable
     * names in the given file. All variables in Blockly are global, so this is
     * necessary to prevent local variables from colliding.
     */
    function buildRenameMap(p: Program, s: SourceFile): RenameMap;
    interface DecompileBlocksOptions {
        snippetMode?: boolean;
    }
    function decompileToBlocks(blocksInfo: pxtc.BlocksInfo, file: ts.SourceFile, options: DecompileBlocksOptions, renameMap?: RenameMap): pxtc.CompileResult;
}
declare namespace ts.pxtc.thumb {
    class ThumbProcessor extends pxtc.assembler.AbstractProcessor {
        constructor();
        wordSize(): number;
        is32bit(i: assembler.Instruction): boolean;
        postProcessAbsAddress(f: assembler.File, v: number): number;
        emit32(v0: number, v: number, actual: string): pxtc.assembler.EmitResult;
        getAddressFromLabel(f: assembler.File, i: assembler.Instruction, s: string, wordAligned?: boolean): number;
        isPop(opcode: number): boolean;
        isPush(opcode: number): boolean;
        isAddSP(opcode: number): boolean;
        isSubSP(opcode: number): boolean;
        peephole(ln: pxtc.assembler.Line, lnNext: pxtc.assembler.Line, lnNext2: pxtc.assembler.Line): void;
        registerNo(actual: string): number;
        testAssembler(): void;
    }
}
declare namespace ts.pxtc.ir {
    enum EK {
        None = 0,
        NumberLiteral = 1,
        PointerLiteral = 2,
        RuntimeCall = 3,
        ProcCall = 4,
        SharedRef = 5,
        SharedDef = 6,
        FieldAccess = 7,
        Store = 8,
        CellRef = 9,
        Incr = 10,
        Decr = 11,
        Sequence = 12,
        JmpValue = 13,
        Nop = 14,
    }
    enum CallingConvention {
        Plain = 0,
        Async = 1,
        Promise = 2,
    }
    class Node {
        isExpr(): this is Expr;
        isStmt(): this is Stmt;
    }
    class Expr extends Node {
        exprKind: EK;
        args: Expr[];
        data: any;
        jsInfo: string;
        totalUses: number;
        currUses: number;
        callingConvention: CallingConvention;
        constructor(exprKind: EK, args: Expr[], data: any);
        static clone(e: Expr): Expr;
        isExpr(): boolean;
        isPure(): boolean;
        isStateless(): boolean;
        sharingInfo(): string;
        toString(): string;
        canUpdateCells(): boolean;
    }
    enum SK {
        None = 0,
        Expr = 1,
        Label = 2,
        Jmp = 3,
        StackEmpty = 4,
        Breakpoint = 5,
    }
    enum JmpMode {
        Always = 1,
        IfZero = 2,
        IfNotZero = 3,
        IfJmpValEq = 4,
    }
    class Stmt extends Node {
        stmtKind: SK;
        expr: Expr;
        lblName: string;
        lbl: Stmt;
        lblNumUses: number;
        jmpMode: JmpMode;
        lblId: number;
        breakpointInfo: Breakpoint;
        stmtNo: number;
        findIdx: number;
        terminateExpr: Expr;
        constructor(stmtKind: SK, expr: Expr);
        isStmt(): boolean;
        toString(): string;
    }
    class Cell {
        index: number;
        def: Declaration;
        info: VariableAddInfo;
        isarg: boolean;
        iscap: boolean;
        _isRef: boolean;
        _isLocal: boolean;
        _isGlobal: boolean;
        bitSize: BitSize;
        constructor(index: number, def: Declaration, info: VariableAddInfo);
        getName(): string;
        getDebugInfo(): CellInfo;
        toString(): string;
        uniqueName(): string;
        refSuffix(): string;
        isRef(): boolean;
        isLocal(): boolean;
        isGlobal(): boolean;
        loadCore(): Expr;
        load(): Expr;
        refCountingHandledHere(): boolean;
        isByRefLocal(): boolean;
        storeDirect(src: Expr): Expr;
        storeByRef(src: Expr): Expr;
        isTemporary: boolean;
    }
    class UnnamedCell extends Cell {
        index: number;
        owningProc: Procedure;
        private static unnamedCellCounter;
        private uid;
        constructor(index: number, owningProc: Procedure);
        getName(): string;
        uniqueName(): string;
        isByRefLocal(): boolean;
        isTemporary: boolean;
    }
    interface ProcId {
        proc: Procedure;
        virtualIndex: number;
        ifaceIndex: number;
        mapMethod?: string;
        mapIdx?: number;
    }
    interface ProcQuery {
        action: ts.FunctionLikeDeclaration;
        bindings: TypeBinding[];
    }
    class Procedure extends Node {
        numArgs: number;
        info: FunctionAddInfo;
        seqNo: number;
        isRoot: boolean;
        locals: Cell[];
        captured: Cell[];
        args: Cell[];
        parent: Procedure;
        debugInfo: ProcDebugInfo;
        bindings: TypeBinding[];
        fillDebugInfo: (th: assembler.File) => void;
        classInfo: ClassInfo;
        body: Stmt[];
        lblNo: number;
        action: ts.FunctionLikeDeclaration;
        reset(): void;
        label(): string;
        matches(id: ProcQuery): boolean;
        toString(): string;
        emit(stmt: Stmt): void;
        emitExpr(expr: Expr): void;
        mkLabel(name: string): Stmt;
        emitLbl(lbl: Stmt): void;
        emitLblDirect(lblName: string): void;
        getName(): string;
        mkLocal(def: Declaration, info: VariableAddInfo): Cell;
        mkLocalUnnamed(isRef?: boolean): UnnamedCell;
        localIndex(l: Declaration, noargs?: boolean): Cell;
        stackEmpty(): void;
        emitClrIfRef(p: Cell): void;
        emitClrs(): void;
        emitJmpZ(trg: string | Stmt, expr: Expr): void;
        emitJmp(trg: string | Stmt, expr?: Expr, mode?: JmpMode, terminate?: Expr): void;
        resolve(): void;
    }
    function iterExpr(e: Expr, f: (v: Expr) => void): void;
    function stmt(kind: SK, expr: Expr): Stmt;
    function op(kind: EK, args: Expr[], data?: any): Expr;
    function numlit(v: number | boolean): Expr;
    function shared(expr: Expr): Expr;
    function ptrlit(lbl: string, jsInfo: string): Expr;
    function rtcall(name: string, args: Expr[]): Expr;
    function rtcallMask(name: string, mask: number, callingConv: CallingConvention, args: Expr[]): Expr;
    function flattenArgs(topExpr: ir.Expr): {
        precomp: Expr[];
        flattened: Expr[];
    };
}
declare namespace ts.pxtc {
    const assert: typeof U.assert;
    const oops: typeof U.oops;
    export import U = pxtc.Util;
    const ON_START_TYPE: string;
    const ON_START_COMMENT: string;
    const TS_STATEMENT_TYPE: string;
    const TS_OUTPUT_TYPE: string;
    const BINARY_JS: string;
    const BINARY_HEX: string;
    const BINARY_ASM: string;
    const BINARY_UF2: string;
    const SK: typeof SyntaxKind;
    const numReservedGlobals: number;
    interface FieldWithAddInfo extends PropertyDeclaration {
        irGetter?: MethodDeclaration;
        irSetter?: MethodDeclaration;
    }
    function getNodeId(n: Node): number;
    function stringKind(n: Node): any;
    function sizeOfBitSize(b: BitSize): number;
    function setCellProps(l: ir.Cell): void;
    const enum BitSize {
        None = 0,
        Int8 = 1,
        UInt8 = 2,
        Int16 = 3,
        UInt16 = 4,
        Int32 = 5,
    }
    interface CommentAttrs {
        debug?: boolean;
        shim?: string;
        enumval?: string;
        helper?: string;
        help?: string;
        async?: boolean;
        promise?: boolean;
        hidden?: boolean;
        callingConvention: ir.CallingConvention;
        block?: string;
        blockId?: string;
        blockGap?: string;
        blockExternalInputs?: boolean;
        blockImportId?: string;
        blockBuiltin?: boolean;
        blockNamespace?: string;
        blockIdentity?: string;
        blockAllowMultiple?: boolean;
        blockHidden?: boolean;
        blockImage?: boolean;
        blockFieldEditor?: string;
        fixedInstances?: boolean;
        fixedInstance?: boolean;
        indexedInstanceNS?: string;
        indexedInstanceShim?: string;
        defaultInstance?: string;
        autoCreate?: string;
        noRefCounting?: boolean;
        color?: string;
        icon?: string;
        imageLiteral?: number;
        weight?: number;
        parts?: string;
        trackArgs?: number[];
        advanced?: boolean;
        deprecated?: boolean;
        useEnumVal?: boolean;
        subcategory?: string;
        subcategories?: string[];
        indexerGet?: string;
        indexerSet?: string;
        mutate?: string;
        mutateText?: string;
        mutatePrefix?: string;
        mutateDefaults?: string;
        mutatePropertyEnum?: string;
        _name?: string;
        _source?: string;
        jsDoc?: string;
        paramHelp?: pxt.Map<string>;
        paramDefl: pxt.Map<string>;
        paramMin?: pxt.Map<string>;
        paramMax?: pxt.Map<string>;
        blockFieldEditorParams?: pxt.Map<string>;
    }
    interface CallInfo {
        decl: Declaration;
        qName: string;
        attrs: CommentAttrs;
        args: Expression[];
        isExpression: boolean;
        isAutoCreate?: boolean;
    }
    interface ClassInfo {
        id: string;
        baseClassInfo: ClassInfo;
        decl: ClassDeclaration;
        numRefFields: number;
        allfields: FieldWithAddInfo[];
        methods: FunctionLikeDeclaration[];
        refmask: boolean[];
        attrs: CommentAttrs;
        isUsed?: boolean;
        vtable?: ir.Procedure[];
        itable?: ir.Procedure[];
        itableInfo?: string[];
        bindings: TypeBinding[];
        ctor?: ir.Procedure;
    }
    interface BinaryExpressionInfo {
        leftType: string;
        rightType: string;
    }
    interface TypeBinding {
        tp: Type;
        isRef: boolean;
    }
    function getComments(node: Node): string;
    function parseCommentString(cmt: string): CommentAttrs;
    function parseCommentsOnSymbol(symbol: Symbol): CommentAttrs;
    function parseComments(node0: Node): CommentAttrs;
    function getName(node: Node & {
        name?: any;
    }): string;
    function getDeclName(node: Declaration): string;
    function getFunctionLabel(node: FunctionLikeDeclaration, bindings: TypeBinding[]): string;
    interface FieldAccessInfo {
        idx: number;
        name: string;
        isRef: boolean;
        shimName: string;
    }
    type VarOrParam = VariableDeclaration | ParameterDeclaration | PropertyDeclaration;
    type TypedDecl = Declaration & {
        type?: TypeNode;
    };
    interface VariableAddInfo {
        captured?: boolean;
        written?: boolean;
    }
    interface FunctionAddInfo {
        capturedVars: VarOrParam[];
        decl: FunctionLikeDeclaration;
        location?: ir.Cell;
        thisParameter?: ParameterDeclaration;
        usages?: TypeBinding[][];
        prePassUsagesEmitted?: number;
        virtualParent?: FunctionAddInfo;
        virtualInstances?: FunctionAddInfo[];
        virtualIndex?: number;
        isUsed?: boolean;
        parentClassInfo?: ClassInfo;
    }
    function compileBinary(program: Program, host: CompilerHost, opts: CompileOptions, res: CompileResult): EmitResult;
    function emptyExtInfo(): ExtensionInfo;
    class Binary {
        procs: ir.Procedure[];
        globals: ir.Cell[];
        globalsWords: number;
        finalPass: boolean;
        target: CompileTarget;
        writeFile: (fn: string, cont: string) => void;
        res: CompileResult;
        options: CompileOptions;
        usedClassInfos: ClassInfo[];
        sourceHash: string;
        checksumBlock: number[];
        strings: Map<string>;
        otherLiterals: string[];
        codeHelpers: Map<string>;
        lblNo: number;
        reset(): void;
        addProc(proc: ir.Procedure): void;
        emitString(s: string): string;
    }
}
declare namespace ts.pxtc {
    interface Breakpoint extends LocationInfo {
        id: number;
        isDebuggerStmt: boolean;
        successors: number[];
        binAddr?: number;
    }
    interface CellInfo {
        name: string;
        type: string;
    }
    interface ProcCallInfo {
        procIndex: number;
        callLabel: string;
        addr: number;
        stack: number;
    }
    interface ProcDebugInfo {
        name: string;
        idx: number;
        bkptLoc: number;
        codeStartLoc: number;
        locals: CellInfo[];
        args: CellInfo[];
        localsMark: number;
        calls: ProcCallInfo[];
    }
    interface CompileResult {
        outfiles: pxt.Map<string>;
        diagnostics: KsDiagnostic[];
        success: boolean;
        times: pxt.Map<number>;
        ast?: Program;
        breakpoints?: Breakpoint[];
        procDebugInfo?: ProcDebugInfo[];
        blocksInfo?: BlocksInfo;
        usedSymbols?: pxt.Map<SymbolInfo>;
        usedArguments?: pxt.Map<string[]>;
        saveOnly?: boolean;
        userContextWindow?: Window;
    }
    function computeUsedParts(resp: CompileResult, ignoreBuiltin?: boolean): string[];
    function getTsCompilerOptions(opts: CompileOptions): CompilerOptions;
    interface LocationInfo {
        fileName: string;
        start: number;
        length: number;
        line: number;
        column: number;
        endLine?: number;
        endColumn?: number;
    }
    interface KsDiagnostic extends LocationInfo {
        code: number;
        category: DiagnosticCategory;
        messageText: string | DiagnosticMessageChain;
    }
    function nodeLocationInfo(node: ts.Node): LocationInfo;
    interface FunctionLocationInfo extends LocationInfo {
        functionName: string;
    }
    function patchUpDiagnostics(diags: Diagnostic[]): KsDiagnostic[];
    function compile(opts: CompileOptions): CompileResult;
    function decompile(opts: CompileOptions, fileName: string): CompileResult;
}
declare namespace ts.pxtc {
    function toStr(v: any): string;
    function format(input: string, pos: number): {
        formatted: string;
        pos: number;
    };
}
declare namespace ts.pxtc {
    const vtableShift: number;
    namespace UF2 {
        const startMagic: string;
        const endMagic: string;
        const UF2_MAGIC_START0: number;
        const UF2_MAGIC_START1: number;
        const UF2_MAGIC_END: number;
        interface Block {
            flags: number;
            targetAddr: number;
            payloadSize: number;
            blockNo: number;
            numBlocks: number;
            data: Uint8Array;
        }
        function parseBlock(block: Uint8Array): Block;
        function parseFile(blocks: Uint8Array): Block[];
        function toBin(blocks: Uint8Array): {
            buf: Uint8Array;
            start: number;
        };
        interface BlockFile {
            currBlock: Uint8Array;
            currPtr: number;
            blocks: Uint8Array[];
            ptrs: number[];
        }
        function newBlockFile(): BlockFile;
        function serializeFile(f: BlockFile): string;
        function readBytes(blocks: Block[], addr: number, length: number): Uint8Array;
        function writeBytes(f: BlockFile, addr: number, bytes: number[]): void;
        function writeHex(f: BlockFile, hex: string[]): void;
    }
    namespace hex {
        let bytecodeStartAddrPadded: number;
        let asmTotalSource: string;
        const defaultPageSize: number;
        interface ChecksumBlock {
            magic: number;
            endMarkerPos: number;
            endMarker: number;
            regions: {
                start: number;
                length: number;
                checksum: number;
            }[];
        }
        function parseChecksumBlock(buf: ArrayLike<number>, pos?: number): ChecksumBlock;
        function hexDump(bytes: ArrayLike<number>, startOffset?: number): string;
        function setupInlineAssembly(opts: CompileOptions): void;
        function isSetupFor(extInfo: ExtensionInfo): boolean;
        let currentHexInfo: pxtc.HexInfo;
        function flashCodeAlign(opts: CompileTarget): number;
        function setupFor(opts: CompileTarget, extInfo: ExtensionInfo, hexinfo: pxtc.HexInfo): void;
        function validateShim(funname: string, shimName: string, hasRet: boolean, numArgs: number): void;
        function lookupFunc(name: string): FuncInfo;
        function lookupFunctionAddr(name: string): number;
        function hexTemplateHash(): string;
        function hexPrelude(): string;
        function patchHex(bin: Binary, buf: number[], shortForm: boolean, useuf2: boolean): string[];
    }
    function asmline(s: string): string;
    function processorInlineAssemble(nativeType: string, src: string): number[];
    function processorEmit(bin: Binary, opts: CompileOptions, cres: CompileResult): void;
    let validateShim: typeof hex.validateShim;
}
declare namespace ts.pxtc {
    function plainTsc(dir: string): Program;
}
declare namespace ts.pxtc {
    interface ParameterDesc {
        name: string;
        description: string;
        type: string;
        initializer?: string;
        defaults?: string[];
        properties?: PropertyDesc[];
        options?: Map<PropertyOption>;
        isEnum?: boolean;
    }
    interface PropertyDesc {
        name: string;
        type: string;
    }
    interface PropertyOption {
        value: string;
    }
    enum SymbolKind {
        None = 0,
        Method = 1,
        Property = 2,
        Function = 3,
        Variable = 4,
        Module = 5,
        Enum = 6,
        EnumMember = 7,
        Class = 8,
        Interface = 9,
    }
    interface SymbolInfo {
        attributes: CommentAttrs;
        name: string;
        namespace: string;
        kind: SymbolKind;
        parameters: ParameterDesc[];
        retType: string;
        extendsTypes?: string[];
        isContextual?: boolean;
        qName?: string;
        pkg?: string;
    }
    interface ApisInfo {
        byQName: pxt.Map<SymbolInfo>;
    }
    interface BlocksInfo {
        apis: ApisInfo;
        blocks: SymbolInfo[];
        blocksById: pxt.Map<SymbolInfo>;
    }
    interface CompletionEntry {
        name: string;
        kind: string;
        qualifiedName: string;
    }
    interface CompletionInfo {
        entries: pxt.Map<SymbolInfo>;
        isMemberCompletion: boolean;
        isNewIdentifierLocation: boolean;
        isTypeLocation: boolean;
    }
    const placeholderChar: string;
    const defaultImgLit: string;
    function localizeApisAsync(apis: pxtc.ApisInfo, mainPkg: pxt.MainPackage): Promise<pxtc.ApisInfo>;
    /**
     * Unlocalized category name for a symbol
     */
    function blocksCategory(si: SymbolInfo): string;
    function renderCall(apiInfo: pxtc.ApisInfo, si: SymbolInfo): string;
    function renderParameters(apis: pxtc.ApisInfo, si: SymbolInfo, cursorMarker?: string): string;
    function getBlocksInfo(info: ApisInfo): BlocksInfo;
    interface GenMarkdownOptions {
        package?: boolean;
        locs?: boolean;
        docs?: boolean;
    }
    function genMarkdown(pkg: string, apiInfo: ApisInfo, options?: GenMarkdownOptions): pxt.Map<string>;
    function getApiInfo(program: Program, legacyOnly?: boolean): ApisInfo;
    function getFullName(typechecker: TypeChecker, symbol: Symbol): string;
    function fillCompletionEntries(program: Program, symbols: Symbol[], r: CompletionInfo, apiInfo: ApisInfo): void;
}
declare namespace ts.pxtc.service {
    interface OpArg {
        fileName?: string;
        fileContent?: string;
        position?: number;
        options?: CompileOptions;
        search?: SearchOptions;
    }
    interface SearchOptions {
        subset?: Map<boolean>;
        term: string;
    }
    interface SearchInfo {
        id: string;
        name: string;
        qName?: string;
        block?: string;
        namespace?: string;
        jsdoc?: string;
        field?: [string, string];
    }
    function performOperation(op: string, arg: OpArg): any;
}
