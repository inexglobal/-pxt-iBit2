/// <reference path="../localtypings/blockly.d.ts" />
/// <reference path="pxtlib.d.ts" />
/// <reference path="../typings/globals/jquery/index.d.ts" />
import B = Blockly;
declare namespace pxt.blocks {
    enum NT {
        Prefix = 0,
        Infix = 1,
        Block = 2,
        NewLine = 3,
    }
    interface JsNode {
        type: NT;
        children: JsNode[];
        op: string;
        id?: string;
        glueToBlock?: boolean;
        canIndentInside?: boolean;
        noFinalNewline?: boolean;
    }
    function mkText(s: string): JsNode;
    function mkGroup(nodes: JsNode[]): JsNode;
    class Point {
        link: Point;
        type: string;
        constructor(link: Point, type: string);
    }
    function compileExpression(e: Environment, b: B.Block, comments: string[]): JsNode;
    interface Environment {
        workspace: Blockly.Workspace;
        bindings: Binding[];
        stdCallTable: pxt.Map<StdFunc>;
        errors: B.Block[];
        renames: RenameMap;
    }
    interface RenameMap {
        oldToNew: Map<string>;
        takenNames: Map<boolean>;
    }
    enum VarUsage {
        Unknown = 0,
        Read = 1,
        Assign = 2,
    }
    interface Binding {
        name: string;
        type: Point;
        declaredInLocalScope: number;
        assigned?: VarUsage;
        mustBeGlobal?: boolean;
    }
    function escapeVarName(name: string, e: Environment): string;
    interface StdArg {
        field?: string;
        literal?: string | number;
    }
    interface StdFunc {
        f: string;
        args: StdArg[];
        attrs: ts.pxtc.CommentAttrs;
        isExtensionMethod?: boolean;
        imageLiteral?: number;
        hasHandler?: boolean;
        property?: boolean;
        namespace?: string;
        isIdentity?: boolean;
    }
    function mkEnv(w: B.Workspace, blockInfo?: pxtc.BlocksInfo, skipVariables?: boolean): Environment;
    function compileBlock(b: B.Block, blockInfo: pxtc.BlocksInfo): BlockCompilationResult;
    function callKey(e: Environment, b: B.Block): string;
    interface SourceInterval {
        id: string;
        start: number;
        end: number;
    }
    interface BlockCompilationResult {
        source: string;
        sourceMap: SourceInterval[];
    }
    function findBlockId(sourceMap: SourceInterval[], loc: {
        start: number;
        length: number;
    }): string;
    function compile(b: B.Workspace, blockInfo: pxtc.BlocksInfo): BlockCompilationResult;
}
declare namespace pxt.blocks {
    function saveWorkspaceXml(ws: Blockly.Workspace): string;
    /**
     * Loads the xml into a off-screen workspace (not suitable for size computations)
     */
    function loadWorkspaceXml(xml: string, skipReport?: boolean): B.Workspace;
    function importXml(xml: string, info: pxtc.BlocksInfo, skipReport?: boolean): string;
    /**
     * Convert blockly hue to rgb
     */
    function convertColour(colour: string): string;
}
declare namespace pxt.blocks.layout {
    function patchBlocksFromOldWorkspace(blockInfo: ts.pxtc.BlocksInfo, oldWs: B.Workspace, newXml: string): string;
    function verticalAlign(ws: B.Workspace, emPixels: number): void;
    function shuffle(ws: B.Workspace, ratio?: number): void;
    function flow(ws: B.Workspace, ratio?: number): void;
    function screenshotAsync(ws: B.Workspace): Promise<string>;
    function toPngAsync(ws: B.Workspace): Promise<string>;
    function svgToPngAsync(svg: SVGGElement, customCss: string, x: number, y: number, width: number, height: number): Promise<string>;
    function toSvg(ws: B.Workspace): {
        width: number;
        height: number;
        xml: string;
    };
}
import Util = pxt.Util;
declare let lf: typeof pxtc.U.lf;
declare namespace pxt.blocks {
    const blockColors: Map<number | string>;
    enum CategoryMode {
        All = 0,
        None = 1,
        Basic = 2,
    }
    const buildinBlockStatements: Map<boolean>;
    function blockSymbol(type: string): pxtc.SymbolInfo;
    function appendToolboxIconCss(className: string, i: string): void;
    function injectToolboxIconCss(): void;
    function hasArrowFunction(fn: pxtc.SymbolInfo): boolean;
    interface BlockFilters {
        namespaces?: {
            [index: string]: FilterState;
        };
        blocks?: {
            [index: string]: FilterState;
        };
        defaultState?: FilterState;
    }
    enum FilterState {
        Hidden = 0,
        Visible = 1,
        Disabled = 2,
    }
    function createToolbox(blockInfo: pxtc.BlocksInfo, toolbox?: Element, showCategories?: CategoryMode, filters?: BlockFilters): Element;
    function initBlocks(blockInfo: pxtc.BlocksInfo, toolbox?: Element, showCategories?: CategoryMode, filters?: BlockFilters): Element;
    let cachedSearchTb: Element;
    function initSearch(workspace: Blockly.Workspace, tb: Element, searchAsync: (searchFor: pxtc.service.SearchOptions) => Promise<pxtc.service.SearchInfo[]>, updateToolbox: (tb: Element) => void): void;
    function cleanBlocks(): void;
    var onShowContextMenu: (workspace: Blockly.Workspace, items: Blockly.ContextMenu.MenuItem[]) => void;
}
declare namespace pxt.blocks {
    /**
     * This interface defines the optionally defined functions for mutations that Blockly
     * will call if they exist.
     */
    interface MutatingBlock extends Blockly.Block {
        mutation: Mutation;
        mutationToDom(): Element;
        domToMutation(xmlElement: Element): void;
        compose(topBlock: Blockly.Block): void;
        decompose(workspace: Blockly.Workspace): Blockly.Block;
    }
    /**
     * Represents a mutation of a block
     */
    interface Mutation {
        /**
         * Get the unique identifier for this type of mutation
         */
        getMutationType(): string;
        /**
         * Compile the mutation of the block into a node representation
         */
        compileMutation(e: Environment, comments: string[]): JsNode;
        /**
         * Get a mapping of variables that were declared by this mutation and their types.
         */
        getDeclaredVariables(): pxt.Map<string>;
        /**
         * Returns true if a variable with the given name was declared in the mutation's compiled node
         */
        isDeclaredByMutation(varName: string): boolean;
    }
    namespace MutatorTypes {
        const ObjectDestructuringMutator: string;
        const RestParameterMutator: string;
        const DefaultInstanceMutator: string;
    }
    function addMutation(b: MutatingBlock, info: pxtc.SymbolInfo, mutationType: string): void;
    function mutateToolboxBlock(block: Node, mutationType: string, mutation: string): void;
}
declare namespace pxt.blocks {
    enum BlockLayout {
        Align = 1,
        Shuffle = 2,
        Clean = 3,
        Flow = 4,
    }
    interface BlocksRenderOptions {
        emPixels?: number;
        layout?: BlockLayout;
        clean?: boolean;
        aspectRatio?: number;
        package?: string;
        snippetMode?: boolean;
    }
    function render(blocksXml: string, options?: BlocksRenderOptions): HTMLElement;
    function blocksMetrics(ws: Blockly.Workspace): {
        width: number;
        height: number;
    };
}
declare namespace pxt.docs.codeCard {
    interface CodeCardRenderOptions {
        hideHeader?: boolean;
        shortName?: boolean;
    }
    function render(card: pxt.CodeCard, options?: CodeCardRenderOptions): HTMLElement;
}
